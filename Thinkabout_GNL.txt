重大なメモリリーク:
while(1) ループの中で、buf1 が毎回新しく ft_calloc で確保されています。しかし、ループの最後に free(buf1) が実行されるのは特定の条件（改行が見つかった場合やエラー時）のみです。ループが継続する場合（改行がない場合）、前回の buf1 のメモリが解放されずに上書きされ、リークします。
同様に、buf2 の内容も次のループで ft_strcpy で上書きされる際に、以前の内容が解放されずリークします。
最も深刻なのは ptrj です。ft_strjoin は新しいメモリを確保しますが、次のループで再度 ft_strjoin を呼び出す前に、前回の ptrj が解放されていません。これにより、ループごとに大量のメモリがリークします。
ptrj の初期化と使用:
ptrj は buf2[0] == '\0' の条件分岐の後でしか初期化されません。もし buf2[0] != '\0' の状態で初めてループに入った場合、ptrj は未初期化のまま ft_strjoin(ptrj, buf1) で使用され、未定義動作を引き起こします。
ft_strjoin の非効率な使用:
ループごとに文字列全体の結合を繰り返すため、非常に非効率です。文字列が長くなるにつれて、メモリ確保とコピーのコストが増大します。
また、上記のメモリリーク問題と合わせて、メモリ管理が非常に複雑でエラーを起こしやすくなっています。
buf2 の役割と使い方:
buf2 は読み込んだデータを一時保存するために使われていますが、その使い方が非常に混乱しています。ループの最後で ft_strcpy(buf2, buf1) していますが、その直前の ft_strjoin では buf2 の内容が適切に使われているか不明確です。
バッファサイズの管理 (GUARD_BS - 1 で読み込み):
read(fd, buf1, GUARD_BS - 1) で NULL 終端のためのスペースを1バイト残していますが、ft_calloc で確保したメモリはもともとゼロ初期化されているため、この GUARD_BS - 1 は適切に機能します。しかし、読み込んだバイト数 sz_read を適切に扱わず、常に ft_strchr や ft_strjoin に渡すのは安全ですが非効率です。
全体的な設計:
この設計では、ファイルの最後まで一度にすべて読み込もうとするか、改行が見つかるまで読み込みを続けます。これは get_next_line（1行ずつ読み込む関数）の一般的な要件を満たしていません。通常、GNLでは、読み込みバッファの一部に残った次の行のデータ（静的変数などで保持すべきデータ）を管理する必要があります。

＜改善策＞
改行までの長さを求めてから、バッファに書き込む。

どう求める？：改行までの長さ
